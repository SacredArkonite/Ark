{
  "dependancies": [
    { "l": "json_util.h" },
    { "l": "jsoncpp\\json\\json.h" },
    { "c": "sstream" },
    { "c": "iostream" }
  ],
  "inputs": [
    {
      "type": "Json::Value",
      "name": "connection_list"
    },
    {
      "type": "Json::Value",
      "name": "operation_list"
    }
  ],
  "outputs": [
    {
      "type": "std::stringstream",
      "name": "ss"
    }
  ],
  //Additionnal stuff because lambda in lambda needs to pass the scope or something..    get_input_index, &find_operation_ops, &get_input_index_index
  "additionnal": [
    {
      "name": "get_input_index"
    },
    {
      "name": "find_operation"
    },
    {
      "name": "&find_operation_ops"
    },
    {
      "name": "&get_input_index_index"
    }
  ],
  "instructions": [
    { "op": "ss << \"//CREATE THE EXECUTION FLOW\" << std::endl;" },
    { "op": "for each (Json::Value block in connection_list)" },
    { "op": "{" },
    { "op": "std::string dest_block = block[\"block\"].asString();" },
    { "op": "find_operation(operation_list, dest_block);" },
    { "op": "" },
    { "op": "std::vector<std::string> input_map(block[\"inputs\"].size());" },
    { "op": "//Map with destination port index. This is to allow swap of inputs in an arkop without needing to adjust the arksch." },
    { "op": "for each (Json::Value input in block[\"inputs\"])" },
    { "op": "{" },
    { "op": "//Collect the source of the connection" },
    { "op": "std::string source_name;" },
    { "op": "if (input[\"source\"][\"output\"].asString() == \"\")" },
    { "op": "source_name = input[\"source\"][\"block\"].asString();" },
    { "op": "else" },
    { "op": "source_name = input[\"source\"][\"block\"].asString() + \"_\" + input[\"source\"][\"output\"].asString();" },
    { "op": "" },
    { "op": "//Find input index" },
    { "op": "get_input_index(find_operation_ops, input[\"input\"].asString());  //BAD CODE WE CANNOT ASSUME THE OUTPUT WE NEED TO CALL! (find_operation_ops)" },
    { "op": "if (get_input_index_index != -1) //BAD CODE WE CANNOT ASSUME THE OUTPUT WE NEED TO CALL! (get_input_index_index)" },
    { "op": "input_map[get_input_index_index] = source_name;" },
    { "op": "else" },
    { "op": "std::cout << input[\"input\"].asString() << \"not found in \" << find_operation_ops << \".\" << std::endl;" },
    { "op": "}" },
    { "op": "" },
    { "op": "ss << block[\"block\"].asString() << \"(\";" },
    { "op": "for (auto it : input_map)" },
    { "op": "ss << \" \" << it << \",\" ;" },
    { "op": "" },
    { "op": "ss.seekp(-1, ss.cur);" },
    { "op": "ss << \");\" << std::endl;" },
    { "op": "}" }
  ]
}